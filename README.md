# Трекер задач 
## Спринт №3
Как системы контроля версий помогают команде работать с общим кодом, так и трекеры задач позволяют эффективно организовать совместную работу над задачами. Вам предстоит написать бэкенд для такого трекера. В итоге должна получиться программа, отвечающая за формирование модели данных для этой страницы:
![трекер задач](https://user-images.githubusercontent.com/63973151/226165153-9d3adf86-993f-4472-b998-04a423356844.png)

**Типы задач**
###
Простейшим кирпичиком такой системы является задача (англ. task). У задачи есть следующие свойства:
Название, кратко описывающее суть задачи (например, «Переезд»).
Описание, в котором раскрываются детали.
Уникальный идентификационный номер задачи, по которому её можно будет найти.
Статус, отображающий её прогресс. Мы будем выделять следующие этапы жизни задачи:
- NEW — задача только создана, но к её выполнению ещё не приступили.
- IN_PROGRESS — над задачей ведётся работа.
- DONE — задача выполнена.

Иногда для выполнения какой-нибудь масштабной задачи её лучше разбить на подзадачи (англ. subtask). 
Большую задачу, которая делится на подзадачи, мы будем называть эпиком (англ. epic). 
Таким образом, в нашей системе задачи могут быть трёх типов: обычные задачи, эпики и подзадачи. Для них должны выполняться следующие условия:
Для каждой подзадачи известно, в рамках какого эпика она выполняется.
Каждый эпик знает, какие подзадачи в него входят.
Завершение всех подзадач эпика считается завершением эпика.

## Спринт 4
**История просмотров задач**
###
Добавьте в программу новую функциональность — нужно, чтобы трекер отображал последние просмотренные пользователем задачи. Для этого добавьте метод getHistory() в  TaskManager и реализуйте его — он должен возвращать последние 10 просмотренных задач. Просмотром будем считаться вызов у менеджера методов получения задачи по идентификатору  — getTask(), getSubtask() и getEpic(). От повторных просмотров избавляться не нужно.
![история просмотров](https://user-images.githubusercontent.com/63973151/226165876-ba7a7271-e291-4a31-8c61-1f1e8a7c1b25.png)

## Cпринт 5
**CustomLinkedList, избавляемся отповторений в истории просмотров**
###
Программа должна запоминать порядок вызовов метода add, ведь именно в этом порядке просмотры будут выстраиваться в истории. Для хранения порядка вызовов удобно использовать список.
Если какая-либо задача просматривалась несколько раз, в истории должен отобразиться только последний просмотр. Предыдущий просмотр должен быть удалён сразу же после появления нового — за O(1). Из темы о списках вы узнали, что константное время выполнения операции может гарантировать связный список CustomLinkedList. Однако его стандартная реализация в данном случае не подойдёт. Поэтому вам предстоит написать собственную.
CustomLinkedList позволяет удалить элемент из произвольного места за О(1) с одним важным условием — если программа уже дошла до этого места по списку. Чтобы выполнить условие, создайте стандартную HashMap. Её ключом будет id задачи, просмотр которой требуется удалить, а значением — место просмотра этой задачи в списке, то есть узел связного списка. С помощью номера задачи можно получить соответствующий ему узел связного списка и удалить его. Реализация метода getHistory должна перекладывать задачи из связного списка в ArrayList для формирования ответа.
![image](https://user-images.githubusercontent.com/63973151/226166055-ae2184ba-a3b0-4fbf-a6ef-885198f312c7.png)

## Спринт 6
**Вторая реализация менеджера**
###
В этом спринте мы добавили в трекер задач ещё одну полезную опцию. Текущая реализация хранит состояние менеджера в оперативной памяти, из-за этого после перезапуска приложения все нужные нам данные теряются. Решить эту проблему может такой класс менеджера, который будет после каждой операции автоматически сохранять все задачи и их состояние в специальный файл.
Нам предстоит создать вторую реализацию менеджера. У него будет такая же система классов и интерфейсов, как и у нынешнего. Новый и старый менеджеры будут отличаться только деталями реализации методов: один хранит информацию в оперативной памяти, другой — в файле. 
Предлагается два варианта реализации на выбор:
![image](https://user-images.githubusercontent.com/63973151/226166238-61229ee8-2c8e-4d15-8598-4ba1e5664125.png)
или
![image](https://user-images.githubusercontent.com/63973151/226166250-bdbbbf4f-6224-4156-b760-d149249783f1.png)

**Результаты выполнения**
![image](https://user-images.githubusercontent.com/63973151/226166333-3796c369-bcaa-4e20-ac26-81ecbac4140d.png)

## Спринт 7
**Расширяем функционал**
###
Добавьте новые поля в задачи:
-duration — продолжительность задачи, оценка того, сколько времени она займёт в минутах (число);
-startTime — дата, когда предполагается приступить к выполнению задачи.
-getEndTime() — время завершения задачи, которое рассчитывается исходя из startTime и duration.
Менять сигнатуры методов интерфейса TaskManager не понадобится: при создании или обновлении задач все его методы будут принимать и возвращать объект, в который вы добавите два новых поля.
С классом Epic придётся поработать дополнительно. Продолжительность эпика — сумма продолжительности всех его подзадач. Время начала — дата старта самой ранней подзадачи, а время завершения — время окончания самой поздней из задач. Новые поля duration и startTime этого класса будут расчётные — аналогично полю статус. Для реализации getEndTime() удобно добавить поле endTime в Epic и рассчитать его вместе с другими полями.
Не забудьте также доработать опцию сохранения состояния в файл: добавьте в сериализацию новые поля.

**JUnit тесты**
###
В данном спринте по мимо расширения функционала так же были написаны Unit-тесты

## Спринт 8

Возвращаемся к работе над менеджером задач. Основная логика приложения реализована, теперь можно сделать для него API. Вам предстоит настроить доступ к методам менеджера  через HTTP-запросы.  

**Прорабатываем логику API**
###
Нам нужно реализовать API, где эндпоинты будут соответствовать вызовам базовых методов интерфейса TaskManager. Соответствие эндпоинтов и методов называется маппингом. Вот как это должно будет выглядеть.
![image](https://user-images.githubusercontent.com/63973151/226166628-b22f96a5-9e1b-4384-ae53-0c15fafb96df.png)

**Доделываем HTTP-сервер для хранения задач**
###
Сейчас задачи хранятся в файлах. Нужно перенести их на сервер. Для этого напишем HTTP-клиент. С его помощью мы переместим хранение состояния менеджера из файлов на отдельный сервер. 
Шаблон сервера находится в репозитории — https://github.com/praktikum-java/java-core-bighw-kvserver. Склонируйте его и перенесите в проект класс KVServer. В классе Main посмотрите пример, как запустить сервер правильно. Добавьте такой же код в свой проект. В примере сервер запускается на порту 8078, если нужно, это можно изменить.
![image](https://user-images.githubusercontent.com/63973151/226166701-05e55df7-54e1-4f22-9727-4c4bb34e9ca8.png)

**Пишем HTTP-клиент**
###
Для работы с хранилищем нам потребуется HTTP-клиент, который будет делегировать вызовы методов в HTTP-запросы. Создаем класс KVTaskClient. Его будет использовать класс HttpTaskManager, который мы скоро напишем.
При создании KVTaskClient учтите следующее:
Конструктор принимает URL к серверу хранилища и регистрируется. При регистрации выдаётся токен (API_TOKEN), который нужен при работе с сервером.
Метод void put(String key, String json) должен сохранять состояние менеджера задач через запрос POST /save/<ключ>?API_TOKEN=.
Метод String load(String key) должен возвращать состояние менеджера задач через запрос GET /load/<ключ>?API_TOKEN=.
Далее проверьте код клиента в main. Для этого запустите KVServer, создайте экземпляр KVTaskClient. Затем сохраните значение под разными ключами и проверьте, что при запросе возвращаются нужные данные. Удостоверьтесь, что если изменить значение, то при повторном вызове вернётся уже не старое, а новое. 





